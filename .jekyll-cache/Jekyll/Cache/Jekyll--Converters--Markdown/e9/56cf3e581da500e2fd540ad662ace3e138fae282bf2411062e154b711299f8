I"<table>
  <thead>
    <tr>
      <th>Day</th>
      <th>Segments</th>
      <th>Learned</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>01</td>
      <td>001 - 027</td>
      <td>√</td>
    </tr>
    <tr>
      <td>02</td>
      <td>028 - 052</td>
      <td>√</td>
    </tr>
    <tr>
      <td>03</td>
      <td>053 - 069</td>
      <td>√</td>
    </tr>
    <tr>
      <td>04</td>
      <td>070 - 088</td>
      <td>√</td>
    </tr>
    <tr>
      <td>05</td>
      <td>089 - 103</td>
      <td>√</td>
    </tr>
    <tr>
      <td>06</td>
      <td>104 - 127</td>
      <td>√</td>
    </tr>
    <tr>
      <td>07</td>
      <td>128 - 150</td>
      <td>×</td>
    </tr>
    <tr>
      <td>08</td>
      <td>151 - 170</td>
      <td>×</td>
    </tr>
    <tr>
      <td>09-10</td>
      <td>171 - 191</td>
      <td>××</td>
    </tr>
  </tbody>
</table>

<h2 id="重点javascript的引入方式">重点：JavaScript的引入方式</h2>

<ol>
  <li>内嵌式</li>
  <li>外链式：JS的外链方式用<code class="language-plaintext highlighter-rouge">src</code>属性，而不是<code class="language-plaintext highlighter-rouge">href</code>属性（<code class="language-plaintext highlighter-rouge">href</code>属性用在<code class="language-plaintext highlighter-rouge">a</code>标签和<code class="language-plaintext highlighter-rouge">link</code>标签中）</li>
  <li>在HTML标签中事件属性中引入
    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">事件属性=</span><span class="s">"JavaScript代码"</span><span class="nt">&gt;&lt;/div&gt;</span>
</code></pre></div>    </div>
    <p>比如：</p>
    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">onclick=</span><span class="s">"alert('1111')"</span><span class="nt">&gt;&lt;/div&gt;</span>
</code></pre></div>    </div>
  </li>
  <li>在a标签中href属性值中写入
    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"javascript:JS代码"</span><span class="nt">&gt;</span>点击弹出对话框<span class="nt">&lt;/a&gt;</span>
</code></pre></div>    </div>
    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"javascript:alert('2222')"</span><span class="nt">&gt;</span>点击弹出对话框<span class="nt">&lt;/a&gt;</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="consolelog"><code class="language-plaintext highlighter-rouge">console.log()</code></h2>

<p>可以输出多个变量，用逗号隔开</p>

<h2 id="基本概念">基本概念</h2>

<h3 id="语法--标识符-identifier">语法 &gt; 标识符 Identifier</h3>

<p>就是指变量、函数、属性的名字。</p>

<ul>
  <li>第一个字符必须是一个字母、下划线或者一个美元符号</li>
  <li>其他字符可以是字母、下划线、美元符号或数字</li>
</ul>

<h3 id="关键字和保留字">关键字和保留字</h3>

<p>见《JavaScript 高级程序设计》，跳转到40页。</p>

<h3 id="重点变量">重点：变量</h3>

<p>ECMAScript的变量是松散类型的。所谓松散类型，就是可以用来保存任何类型的数据。</p>

<p>每个变量仅仅是一个用于保存值的占位符而已。定义变量时要使用var操作符。
未经过初始化的变量，会保存一个特殊的值，undefined。</p>

<p>在函数中定义变量，这个变量在函数退出后会被销毁。</p>

<h3 id="重点数据类型">重点：数据类型</h3>

<ul>
  <li>Undefined</li>
  <li>Null</li>
  <li>Boolean</li>
  <li>Number</li>
  <li>String</li>
  <li>Object</li>
</ul>

<h4 id="typeof-操作符">typeof 操作符</h4>

<p>检测给定变量的数据类型，可能返回下列某个字符串：</p>

<ul>
  <li>‘undefined’: 如果这个值未定义</li>
  <li>‘boolean’</li>
  <li>‘string’</li>
  <li>‘number’</li>
  <li>‘object’：如果这个值是对象，或是null，这其实就是JS的一个bug（这么理解，null是空对象，所以数据类型就是对象）</li>
  <li>‘function’</li>
</ul>

<p>typeof是操作符，而不是函数，因此操作数并不需要包含在括号中。</p>

<h4 id="undefined类型">Undefined类型</h4>

<p>Undefined类型只有一个值，即特殊的undefined。</p>

<pre><code class="language-JavaScript">var message
alert (message == undefined); // true
</code></pre>

<p><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">阮一峰关于null和undefined的博客文章</a></p>

<h4 id="null类型">Null类型</h4>

<pre><code class="language-JavaScript">var car = null;
alert(typeof car); // 'object'
</code></pre>

<p>实际上，undefined值是派生自null值的。因此ECMA-262规定对它们的相等性测试要返回true：</p>

<pre><code class="language-JavaScript">alert(null == undefined); // true
</code></pre>

<p>尽管<code class="language-plaintext highlighter-rouge">null</code>和<code class="language-plaintext highlighter-rouge">undefined</code>有这样的关系，但是它们的用途完全不同。无论在什么情况下，都没有必要把一个变量的值显式地设置为undefined，可是同样的规则对<code class="language-plaintext highlighter-rouge">null</code>却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为<strong>空对象指针</strong>的惯例，而且也有助于进一步区分null和undefined。</p>

<h4 id="null和undefined的比较"><code class="language-plaintext highlighter-rouge">null</code>和<code class="language-plaintext highlighter-rouge">undefined</code>的比较</h4>

<p>相同点：均代表无值</p>

<p>不同点：undefined代表一个变量没有赋值，null代表一个变量存储的值是引用类型，但是目前对象还没有创建，另外如果一个函数应该有返回值，但是最终没有数据作为返回值，那么也会返回<code class="language-plaintext highlighter-rouge">null</code>，总而言之，null表示一个空对象</p>

<h4 id="boolean">Boolean</h4>

<p>要将一个值转换为其对应的Boolean值，可以调用转换类型函数<code class="language-plaintext highlighter-rouge">Boolean()</code>。</p>

<p>可以对任何数据类型的值调用<code class="language-plaintext highlighter-rouge">Boolean()</code>函数，而且总会返回一个Boolean值，至于返回的这个值是true还是false，取决于要转换值的类型以及实际的值。</p>

<p>除了0 “” ‘’ undefined NaN null得到false，其他都是true</p>

<pre><code class="language-JavaScript">console.log(Boolean(" ")) // =&gt;true
</code></pre>

<h4 id="数值">数值</h4>

<h5 id="浮点数值">浮点数值</h5>

<p>该数值中必须包含一个小数点，并且小数点后面必须至少有一位数。
对于那些极大或极小的数值，可以用e 表示法（即科学计数法）表示的浮点数值表示。</p>

<h5 id="数值范围">数值范围</h5>

<p>由于内存的限制，ECMAScript 并不能保存世界上所有的数值。要想确定一个数值是不是有穷的（换句话说，是不是位于最
小和最大的数值之间），可以使用isFinite()函数。</p>

<h5 id="nan">NaN</h5>

<p>NaN = Not a Number</p>

<p>用isNaN()函数来确定这个参数是否“不是数值”。<code class="language-plaintext highlighter-rouge">"10"</code>，这样的String以及布林值的<code class="language-plaintext highlighter-rouge">true</code>和<code class="language-plaintext highlighter-rouge">false</code>都会转换为数值，因此在下面的例子中，返回的值都是<code class="language-plaintext highlighter-rouge">false</code>。</p>

<pre><code class="language-JavaScript">alert(isNaN(NaN)); //true
alert(isNaN(10)); //false（10 是一个数值）
alert(isNaN("10")); //false（可以被转换成数值10）
alert(isNaN("blue")); //true（不能转换成数值）
alert(isNaN(true)); //false（可以被转换成数值1）
</code></pre>

<p><code class="language-plaintext highlighter-rouge">isNaN()</code>甚至适用于Object。在基于对象调用<code class="language-plaintext highlighter-rouge">isNaN()</code>函数时，会首先调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用toString()方法，再测试返回值。</p>

<h4 id="数值转换">数值转换</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Number()</code> 转型函数，适用于任何数据类型
    <ul>
      <li>如果是Boolean值，<code class="language-plaintext highlighter-rouge">true</code>和<code class="language-plaintext highlighter-rouge">false</code>分别将被转换为1和0</li>
      <li>如果是<code class="language-plaintext highlighter-rouge">null</code>，返回0</li>
      <li>如果是<code class="language-plaintext highlighter-rouge">undefined</code>，返回<code class="language-plaintext highlighter-rouge">NaN</code></li>
      <li>如果是字符串：
        <ul>
          <li>字符串中只包含数字：将其转换为十进制数值 (011会变成11)</li>
          <li>字符串中包含有效的浮点格式，转换为对应的浮点数值</li>
          <li>字符串中包含有效的十六进制格式，将其转换为相同大小的十进制整数值</li>
          <li>字符串是空的，转换为0；</li>
          <li>字符串中包含上述格式之外的字符，转换为 <code class="language-plaintext highlighter-rouge">NaN</code>
<code class="language-plaintext highlighter-rouge">Number()</code>函数转换比较复杂，不够合理，在处理整数时，更常用的是<code class="language-plaintext highlighter-rouge">parseInt()</code>函数。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">parseInt()</code>，专门用于把字符串转换成数值：<code class="language-plaintext highlighter-rouge">parseInt()</code>在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，<code class="language-plaintext highlighter-rouge">parseInt()</code>就会返回<code class="language-plaintext highlighter-rouge">NaN</code>，而<code class="language-plaintext highlighter-rouge">Number()</code>对空字符返回0。如果第一个字符是数字字符，<code class="language-plaintext highlighter-rouge">parseInt()</code>会继续解析第二个字符，直至解析完所有后续字符或者遇到了一个非数字字符。比如说，<code class="language-plaintext highlighter-rouge">parseInt('1234blue') // 1234</code>，<code class="language-plaintext highlighter-rouge">parseInt('22.5') // 22</code>    <br />
转换八进制，比如“070”时，ES3和ES5存在分歧。解决方法是为这个函数提供第二个参数：转换时使用的基数（即n进制的n）。比如<code class="language-plaintext highlighter-rouge">var num = parseInt('0xAF', 16)</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">parseFloat()</code>，专门用于把字符串转换成数值，与<code class="language-plaintext highlighter-rouge">parseInt()</code>类似。<code class="language-plaintext highlighter-rouge">parseFloat()</code>只解析十进制值，因此它没有用第二个参数指定基数的用法。</li>
</ul>

<h4 id="string类型">String类型</h4>

<p>注意点：在输出的内容中如果需要使用引号，请使用转移符号“\”。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log("这是一个\"漂亮\"的女孩")
</code></pre></div></div>

<h5 id="字符字面量">字符字面量</h5>

<p>转义序列表示1个字符。任何字符串的长度都可以通过访问其<code class="language-plaintext highlighter-rouge">length</code>属性取得，比如<code class="language-plaintext highlighter-rouge">alert(text.length)</code>。</p>

<p>如果字符串中包含双字节字符，那么length属性可能不会精确地返回字符串中的字符数目。</p>

<h5 id="转换字符串">转换字符串</h5>

<p>有两种方式，第一种是使用几乎每个值都有的<code class="language-plaintext highlighter-rouge">toString()</code>的方法，但是不适用于<code class="language-plaintext highlighter-rouge">null</code>和<code class="language-plaintext highlighter-rouge">undefined</code>类型。</p>

<p>多数情况下，不必传递参数。不过，在调用数值的toString()方法时，可以传递第一个参数：输出数值的基数。可以输出二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。默认以十进制输出。</p>

<p>比如：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var num = 10;
alert(num.toString(2)) // 1010
</code></pre></div></div>

<p>在不知道要转换的值是不是<code class="language-plaintext highlighter-rouge">null</code>或者<code class="language-plaintext highlighter-rouge">undefined</code>的情况下，还可以使用转型函数<code class="language-plaintext highlighter-rouge">String()</code>，这个函数能够将任何类型的值转换为字符串。String()函数遵循下列规则：</p>

<ul>
  <li>如果值有<code class="language-plaintext highlighter-rouge">toString()</code>的方法，则调用该方法（没有参数），并返回相应的结果；</li>
  <li>如果值是<code class="language-plaintext highlighter-rouge">null</code>，则返回”null”；</li>
  <li>如果值是<code class="language-plaintext highlighter-rouge">undefined</code>，则返回”undefined”。</li>
</ul>

<h4 id="object-类型">object 类型</h4>

<p>创建Object类型的实例，并为其添加属性和（或）方法，就可以创建自定义对象。</p>

<pre><code class="language-JavaScript">var o = new Object();
</code></pre>

<p>这个语法与Java中创建对象的语法相似；但在ECMAScript中，如果不给构造函数传递参数，则可以省略后面的那一对圆括号，也就是：</p>

<pre><code class="language-JavaScript">var o = new Object;
</code></pre>
<p>Object的每个实例都具有下列属性和方法：</p>

<ul>
  <li>constructor: 构造函数，也就是上方例子中的<code class="language-plaintext highlighter-rouge">Object()</code></li>
  <li><code class="language-plaintext highlighter-rouge">hasOwnProperty(*PropertyName*)</code>: 用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。作为参数的属性名（propertyName）必须以字符串的形式指定，比如<code class="language-plaintext highlighter-rouge">o.hasOwnProperty("name")</code></li>
  <li><code class="language-plaintext highlighter-rouge">isPrototypeof(object)</code>: 用于检查传入的对象是否传入对象的原型</li>
  <li><code class="language-plaintext highlighter-rouge">propertyIsEnumerable(*propertyName*)</code>: 用于检查给定的属性是否能够使用for-in语句来枚举。</li>
  <li><code class="language-plaintext highlighter-rouge">toLocalString()</code>: 返回对象的字符串表示，该字符串与执行环境的地区对应</li>
  <li><code class="language-plaintext highlighter-rouge">toString()</code>: 返回对象的字符串表示</li>
  <li><code class="language-plaintext highlighter-rouge">valueOf()</code>: 返回对象的字符串、数值或布林值表示。通常与<code class="language-plaintext highlighter-rouge">toString()</code>方法的返回值相同。</li>
</ul>

<h3 id="操作符">操作符</h3>

<ul>
  <li>算数操作符</li>
  <li>位操作符</li>
  <li>关系操作符</li>
  <li>相等操作符</li>
</ul>

<p>应用于对象时，相应的操作符通常会调用对象的<code class="language-plaintext highlighter-rouge">valueOf()</code>和(或)<code class="language-plaintext highlighter-rouge">toString()</code>方法。</p>

<h4 id="一元操作符">一元操作符</h4>

<h5 id="递增和递减">递增和递减</h5>

<ul>
  <li>递增和递减：前置型和后置型，也就是相对于要操作的变量的位置。</li>
</ul>

<p>前置型和后置型有区别。</p>

<pre><code class="language-JavaScript">var num1 = 2;
var num2 = 20;
var num3 = --num1 + num2 // 等于21
var num4 = num1 + num2 // 等于21
</code></pre>

<pre><code class="language-JavaScript">var num1 = 2;
var num2 = 20;
var num3 = num1-- + num2 //等于22
var num4 = num1 + num2 //等于21
</code></pre>

<p><strong>这是因为执行前置递减操作时，变量的值都是在语句被要求值以前改变的。后置则反之。</strong></p>

<p>在应用于不同的值时，递增和递减操作符遵循下列规则：</p>

<ul>
  <li>在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1 的操作。字
符串变量变成数值变量。</li>
  <li>在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN。
字符串变量变成数值变量。</li>
  <li>在应用于布尔值false 时，先将其转换为0 再执行加减1 的操作。布尔值变量变成数值变量。</li>
  <li>在应用于布尔值true 时，先将其转换为1 再执行加减1 的操作。布尔值变量变成数值变量。</li>
  <li>在应用于浮点数值时，执行加减1 的操作。</li>
  <li>在应用于对象时，先调用对象的valueOf()方法以取得一个可供操作的
值。然后对该值应用前述规则。
    <pre><code class="language-JavaScript">var o = {
  valueOf: function() {
    return -1;
  }
};

o-- // 值变成-2
</code></pre>
  </li>
</ul>

<h5 id="一元加和减操作符">一元加和减操作符</h5>

<pre><code class="language-JavaScript">var num = 25;
num = +num // 仍然是25
</code></pre>

<p>在对非数值应用一元操作符时，该操作符会像Number()转型函数一样，对这个执进行转换。</p>

<pre><code class="language-JavaScript">var s1 = "01";

s1 = +s1 //值变成1
</code></pre>

<p>用于表示负数：</p>

<pre><code class="language-JavaScript">var num = 25;
num = -num // 变成-25
</code></pre>

<h4 id="位操作符">位操作符</h4>

<p>按内存中表示数值的位来操作数值。</p>

<p>ECMAScript中所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值，而是先将64位的值转换成32位的整数，最后将结果转换为64位。</p>

<p>对于有符号的整数，32位中的前31位用于表示整数的值，第32位用于表示数值的符号，0表示正数，1表示负数。</p>

<p>负数同样以二进制码存储，但使用的格式是二进制补码，计算需要经过3个步骤：</p>

<ol>
  <li>求这个数值绝对值的二进制码，比如要知道-18的二进制补码，就先要知道18的二进制码，也就是<code class="language-plaintext highlighter-rouge">0000 0000 0000 0000 0000 0000 0001 0010</code></li>
  <li>求其二进制反码，也就是将0和1互换：<code class="language-plaintext highlighter-rouge">1111 1111 1111 1111 1111 1111 1110 1101</code></li>
  <li>最后，二进制反码加1：<code class="language-plaintext highlighter-rouge">1111 1111 1111 1111 1111 1111 1110 1110</code></li>
</ol>

<p>但是ECMAScript会尽力向我们隐藏这些信息，换句话说，在以二进制字符串形式输出一个负数时，我们看到只是这个负数绝对值的二进制码前面加上了一个负号</p>

<pre><code class="language-JavaScript">var num = -18;
alert(toString(2)) // "-10010"
</code></pre>

<h4 id="布尔操作符">布尔操作符</h4>

<ul>
  <li>非 (<code class="language-plaintext highlighter-rouge">NOT</code>)</li>
  <li>与 (<code class="language-plaintext highlighter-rouge">AND</code>)</li>
  <li>或 (<code class="language-plaintext highlighter-rouge">OR</code>)</li>
</ul>

<h5 id="逻辑非">逻辑非</h5>

<p>由一个叹号 (!) 表示，可以应用于ECMAScript中的任何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。</p>

<ul>
  <li>如果操作数是一个对象，返回<code class="language-plaintext highlighter-rouge">false</code></li>
  <li>如果操作数是一个空字符串，返回<code class="language-plaintext highlighter-rouge">true</code></li>
  <li>如果操作数是一个非空字符串，返回<code class="language-plaintext highlighter-rouge">false</code></li>
  <li>如果操作数是数值0，返回<code class="language-plaintext highlighter-rouge">true</code></li>
  <li>如果操作数是任意非0的数值（包括Infinity），返回<code class="language-plaintext highlighter-rouge">false</code></li>
  <li>如果操作数是<code class="language-plaintext highlighter-rouge">null</code>，返回<code class="language-plaintext highlighter-rouge">true</code></li>
  <li>如果操作数是<code class="language-plaintext highlighter-rouge">NaN</code>，返回<code class="language-plaintext highlighter-rouge">true</code></li>
  <li>如果操作数是<code class="language-plaintext highlighter-rouge">undefined</code>，返回<code class="language-plaintext highlighter-rouge">true</code></li>
</ul>

<h5 id="逻辑与">逻辑与</h5>

<p>逻辑与操作符由两个和好(<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>)表示，有两个操作数，比如：</p>

<pre><code class="language-JavaScript">var result = true &amp;&amp; false
</code></pre>

<table>
  <thead>
    <tr>
      <th>第一个操作数</th>
      <th>第二个操作数</th>
      <th>结果</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>true</td>
      <td>true</td>
      <td>true</td>
    </tr>
    <tr>
      <td>true</td>
      <td>false</td>
      <td>false</td>
    </tr>
    <tr>
      <td>false</td>
      <td>true</td>
      <td>false</td>
    </tr>
    <tr>
      <td>false</td>
      <td>false</td>
      <td>false</td>
    </tr>
  </tbody>
</table>

<p>逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。</p>

<pre><code class="language-JavaScript">var a = 1 &amp;&amp; 2 // =&gt;2 如果a为true，直接返回b，而不管b为true或者false。如果a为false，那么就直接返回a

var a=2,b=undefined,c=3;
var d = 2&amp;&amp;b&amp;&amp;c;
console.log(d) // =&gt;undefined，不是布尔值
</code></pre>

<h4 id="逻辑或">逻辑或</h4>

<table>
  <tbody>
    <tr>
      <td>a</td>
      <td> </td>
      <td>b 如果a为false，则直接返回b的值，而不管b为true或者false。如果a为true，直接返回a，而不会继续往下执行</td>
    </tr>
  </tbody>
</table>

<h4 id="相等操作符">相等操作符</h4>

<p>相等和不相等——先转换再比较，全等和不全等——仅比较而不转换。</p>

<h4 id="字符串连接符号">字符串连接符号</h4>

<p>a + b: 如果a和b中至少有一个字符串，此时 + 不是运算符加号，而是连接符，且得到的结果是字符串类型。</p>

<h4 id="赋值运算">赋值运算</h4>

<p>必须是<code class="language-plaintext highlighter-rouge">a+=b</code>，不能是<code class="language-plaintext highlighter-rouge">a=+b</code>，比如<code class="language-plaintext highlighter-rouge">a=+30</code>中的<code class="language-plaintext highlighter-rouge">+</code>只是正号的意思。</p>

<h4 id="运算符优先级">运算符优先级</h4>

<p>不用记住，知道怎么查就可以。</p>

<p><code class="language-plaintext highlighter-rouge">===</code>和<code class="language-plaintext highlighter-rouge">!==</code> <code class="language-plaintext highlighter-rouge">==</code> <code class="language-plaintext highlighter-rouge">!=</code></p>

<h2 id="变量">变量</h2>

<p>多个变量的声明：一个var直接声明多个变量，用逗号隔开。通常把带有赋值的变量放在最后。</p>

<p><code class="language-plaintext highlighter-rouge">var a,b,c = 12</code> 并不是说a，b，c三个变量都赋值12，而是只有c有赋值。</p>

<p>##输出对话框</p>

<p>prompt(‘提示信息’, 默认值)</p>

<ul>
  <li>输入框：根据提示要输入的信息</li>
  <li>确定</li>
  <li>取消：得到的是空对象</li>
</ul>

<p><strong>注意</strong>： <code class="language-plaintext highlighter-rouge">prompt</code>中的默认值是可选值，但是考虑到兼容性的问题，最好写上。</p>

<pre><code class="language-JavaScript">var msg = prompt("您的年龄是：", 12);

console.log(msg, typeof msg); // 得到输入的值或者默认的值，值的类型为String；取消的话，得到的是null，类型是object
</code></pre>
<h2 id="流程控制">流程控制</h2>

<p><code class="language-plaintext highlighter-rouge">{}</code>只是为了包含代码块，如果只有一行需要执行的语句，完全可以去掉大括号。</p>

<pre><code class="language-JavaScript">if(age &gt;= 18) console.log("恭喜你，终于成年了！")
</code></pre>

<h2 id="流程控制-1">流程控制</h2>

<p>分支判断最后的<code class="language-plaintext highlighter-rouge">else</code>可以省略。</p>

<h3 id="swithcase">swith…case…</h3>

<p>语法结构：</p>

<p>switch(判断谁的值) {
  case 值 A：
  执行的代码块 A
  break;</p>

<p>case 值 B：
  执行的代码块 B
  break;</p>

<p>case 值 C：
  执行的代码块 C
  break;</p>

<p>…</p>

<p>default:
  执行代码块D
}</p>

<p>注意事项：switch…case…语句既判断值的大小，也判断数据类型。</p>

<pre><code class="language-JavaScript">var a = prompt('请输入1-10之间的整数', 1);

a = parseInt(a);

switch(a) {
  case 1:
  console.log("春天");
  break;

  case 2:
  console.log("夏天");
  break;

  case 3:
  console.log("秋天");
  break;

  case 4:
  console.log("冬天");
  break

  default: 
  console.log("不在四季中");
}
</code></pre>

<ul>
  <li>
    <p>break的作用是：防止向后穿透代码块，强制跳出。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">default</code>相当于<code class="language-plaintext highlighter-rouge">if...else...</code>中的<code class="language-plaintext highlighter-rouge">else</code>，所以和<code class="language-plaintext highlighter-rouge">else</code>一样，可以省略。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">default</code>的位置可以变化。但是如果不在最后，必须加上break。</p>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">switch...case...</code>和<code class="language-plaintext highlighter-rouge">if...else...</code>的区别：</p>

<p><code class="language-plaintext highlighter-rouge">if...else...</code>可以判断值的大小，也可以判断值的范围，而<code class="language-plaintext highlighter-rouge">switch...case...</code>语句一般只判断值的大小。</p>

<h2 id="循环语句">循环语句</h2>

<h3 id="for-循环">for 循环</h3>

<p>语法结构：</p>

<p>for(定义变量保存初始值；循环条件；更新循环次数) {</p>

<p>}</p>

<h3 id="while-循环">while 循环</h3>

<p>语法结构：</p>

<p>初始化循环变量
while(循环条件) {
  循环体;
  更新循环变量;
}</p>

<h3 id="dowhile循环">do…while…循环</h3>

<p>语法结构：</p>

<p>初始化循环变量
do{
  循环体
  更新循环变量
}while(循环条件);</p>

<h3 id="死循环">死循环</h3>

<p>循环条件永远为真，有两种情况：</p>

<ul>
  <li>没有循环条件，默认就为真</li>
  <li>for(;;)</li>
</ul>

<h3 id="嵌套循环">嵌套循环</h3>

<p>语法结构：
for(外层循环) { // 外层循环相当于表格中的行
  for(内层循环) { // 内层循环相当于表格中的列</p>

<p>}
}</p>

<pre><code class="language-JavaScript">for(i = 0; i &lt; 5; i++) {
            for (j = 0; j &lt; 5; j++) {
                document.write('*');
            }
            document.write('&lt;br&gt;')
        }
</code></pre>

<p>输出到网页的结果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*****  
*****  
*****  
*****  
*****
</code></pre></div></div>

<h4 id="不规则的行和列">不规则的行和列</h4>

<p>找规律（i和j之间的规律）。</p>

<pre><code class="language-JavaScript">for (i = 4; i &gt;= 0; i--) {
                for (j = 0; j &lt; i + 1; j++) {
                    document.write('☆');
                }
                document.write('&lt;br&gt;');
            }
</code></pre>

<p>输出的效果：</p>

<p>☆☆☆☆☆<br />
☆☆☆☆<br />
☆☆☆<br />
☆☆<br />
☆</p>

<h3 id="终止循环">终止循环</h3>

<p>break：强制跳出当前循环<br />
  <em>*注意</em>： 在没有指明跳出具体是哪个循环时，默认跳出当前循环</p>

<pre><code class="language-JavaScript">parentLoop: for (var i = 1; i &lt;= 5; i++) {
    childLoop: for (var j = 1; j &lt;= 5; j++) {
        if (j == 3) {
            break; // end up the child loop and continue with the parent loop
        }
        document.write('*');
    }
    document.write('&lt;br&gt;')
}
</code></pre>
<p>指定的情况：</p>

<pre><code class="language-JavaScript">parentLoop: for (var i = 1; i &lt;= 5; i++) {
  childLoop: for (var j = 1; j &lt;= 5; j++) {
      if (j == 3) {
          break parentLoop; // end up the parent loop altogether
      }
      document.write('*');
  }
  document.write('&lt;br&gt;')
}
</code></pre>

<p>continue：终止本次循环，继续下次循环</p>

<p>因为跳出了父级循环，所以连父级循环中的换行符都省略去了。</p>

<pre><code class="language-JavaScript">parentLoop: for (var i = 1; i &lt;= 5; i++) {
    childLoop: for (var j = 1; j &lt;= 5; j++) {
        if (j == 3) {
            continue parentLoop// end up the child loop and continue with the parent loop
        }
        document.write('*');
    }
    document.write('&lt;br&gt;')
}
</code></pre>

<p>输出效果：</p>

<hr />

<h4 id="跳出多层循环">跳出多层循环</h4>

<h2 id="函数">函数</h2>

<p>L53-L69：递归函数难度高，可以慢慢掌握</p>

<p>函数其实就是对一段代码进行封装，被封装的代码总是完成某项功能，函数不会主动地进行，需要在程序中手动地调用函数（比如：用户点击的时候），并且可以多次调用这个函数。</p>

<h3 id="为什么使用函数">为什么使用函数</h3>

<ul>
  <li>减少代码冗余</li>
  <li>方便后期对代码的维护</li>
</ul>

<h3 id="函数的定义">函数的定义</h3>

<p>两种定义方式：</p>

<ul>
  <li>函数声明式</li>
  <li>函数表达式</li>
</ul>

<h4 id="函数声明式">函数声明式</h4>

<p>function 函数名() {
  函数体（被封装的代码块）
}</p>

<h4 id="函数表达式">函数表达式</h4>

<p>var 变量 = function() {
  函数体（被封装的代码块）
}</p>

<p>注意：</p>
<ul>
  <li>function(){} 匿名函数（没有名称的函数）</li>
  <li>变量名相当于函数名</li>
</ul>

<pre><code class="language-JavaScript">// Encapsulation
var sayHello = function () {
            console.log('Hello World')
        };

// Run the function
sayHello();
</code></pre>

<h4 id="两种函数定义的区别">两种函数定义的区别</h4>

<p><strong>函数声明式可以在定义前调用函数，而函数表达式则不可以。</strong></p>

<p><strong>如果使用函数声明式来定义函数，定义好的函数会自动提升位置，提升到<code class="language-plaintext highlighter-rouge">script</code>开始标签的开始位置。</strong></p>

<h3 id="函数的命名规则">函数的命名规则</h3>

<p>不能使用简单字符，要言之有意。</p>

<p>函数也是一种数据类型，属于引用类型。所以把函数赋值给一个变量是可行的。</p>

<h3 id="形参和实参">形参和实参</h3>

<p>调用函数时传入的实参和形参是一一对应的关系。</p>

<h3 id="带返回值的函数">带返回值的函数</h3>

<p>函数执行后的结果有可能被其它程序调用或者参与其它程序的运算，这时候需要返回值</p>

<p>function 函数名(参数1,参数2,…参数n) {
  return 函数执行后的结果;
}</p>

<h3 id="三元运算符">三元运算符</h3>

<p>a?b:c</p>

<h3 id="带有返回值的函数">带有返回值的函数</h3>

<p>不管函数中有多少个返回值，函数执行的结果是第一次遇到的return的结果。简单地说，函数第一次遇到return，就结束。</p>

<h3 id="变量的作用域">变量的作用域</h3>

<pre><code class="language-JS">var a = 12;

function sum() {
  console.log(a);
  var a = 34;
  console.log(a);
}

sum();
</code></pre>

<p>正如函数声明式会提升到<code class="language-plaintext highlighter-rouge">&lt;script&gt;</code>开始位置类似，函数中变量的定义也会被提升到函数的起始位置，比如上方第一次出现的<code class="language-plaintext highlighter-rouge">console.log(a)</code>会输出<code class="language-plaintext highlighter-rouge">undefined</code>，就是因为函数a的定义被提升到了函数的开始位置，缺少赋值，因此输出为<code class="language-plaintext highlighter-rouge">undefined</code>。程序会以下面的方式进行解读：</p>

<pre><code class="language-JS">var a = 12;

function sum() {
  var a;
  console.log(a);
  a = 34;
  console.log(a);
}

function sum()
</code></pre>

<h3 id="内置函数">内置函数</h3>

<p>也叫做系统函数，比如<code class="language-plaintext highlighter-rouge">String()</code>, <code class="language-plaintext highlighter-rouge">Number()</code>, <code class="language-plaintext highlighter-rouge">Boolean()</code>, <code class="language-plaintext highlighter-rouge">parseInt()</code>, <code class="language-plaintext highlighter-rouge">parseFloat()</code>等</p>

<p><code class="language-plaintext highlighter-rouge">isNaN</code>，判定是否为非数值。如果不是数字，返回true，如果是数字，返回false</p>

<h3 id="递归函数">递归函数</h3>

<p>在函数体内对函数自身的调用</p>

<ul>
  <li>前提：
    <ul>
      <li>必须是一个函数</li>
      <li>必须要有一个递归出口（对函数中的参数进行判断）
参数必须满足一定的条件，才调用函数自身。</li>
    </ul>
  </li>
</ul>

<p>递归函数怎么写？</p>

<ol>
  <li>第一步：假设递归函数已经写好<br />
第n项的值：function f(n) {}<br />
前n项的和：function fsum(n) {}</li>
  <li>寻找递进关系<br />
第n项的值的递进关系：<br />
f(1) = 1;<br />
f(2) = f(1) + 2;<br />
f(3) = f(2) + 2;<br />
…<br />
f(n) = f(n-1) + 2;<br />
前n项的和的递进关系：<br />
fsum(1) = 1;<br />
fsum(2) = fsum(1) + f(2);<br />
fsum(3) = fsum(2) + f(3);<br />
…<br />
fsum(n) = fsum(n-1) + f(n)</li>
  <li>将地推关系添加到假设好的递归函数中，形成递归体：
    <pre><code class="language-JS">// f(n)
function f(n) {
  return f(n-1) + 2;
}
// fsum(n)
function fsum(n) {
  return fsum(n-1) + f(n);
}
</code></pre>
  </li>
  <li>寻找递归出口（临界条件）
    <pre><code class="language-JS">// 第n项的值的临界条件
if(n==1) {
  return 1;
}
// 前n项的和的临界条件
if(n==1) {
  return 1;
}
</code></pre>
  </li>
  <li>进行拼装
    <pre><code class="language-JS">function f(n) {
  if (n == 1) {
      return 1
  }
  return f(n - 1) + 2;
}
function fsum(n) {
if (n == 1) {
    return 1
}
return fsum(n - 1) + f(n);
}
</code></pre>
  </li>
</ol>

<h2 id="数组">数组</h2>

<p>数组是一组数据有序排列的集合。将一组数据按一定顺序组织为一个组合，并对这个组合命名，这样便构成了数组。</p>

<h3 id="数组的定义">数组的定义</h3>

<ul>
  <li>使用 new 字符实例化定义数组
    <pre><code class="language-JS">var arr = new Array();
</code></pre>
  </li>
  <li>使用字面量的方式定义数组 —-&gt; 字面量：常量（固定数据）
    <pre><code class="language-JS">var arr = [/*...*/];
</code></pre>
  </li>
</ul>

<p>使用<code class="language-plaintext highlighter-rouge">new</code>定义的数组，如果数组中只写了一个数字，那么这个数字代表的是数组的长度，而不是数组元素。</p>

<p><code class="language-plaintext highlighter-rouge">var arr = new Array(3);</code></p>

<p>使用索引赋值时，通常以最大的索引为最后一个元素。</p>

<pre><code class="language-JS">var arr3 = [];
arr3[0] = "number";
arr3[1] = "string";
arr3[12] = "boolean";
arr3["name"] = "undefined";
arr3[0] = "null";
console.log(arr3);
console.log(arr3.length);
</code></pre>

<h3 id="栈区和堆">栈区和堆</h3>

<p>内存分为两个区域：</p>

<ul>
  <li>栈区： 用于存放
    <ul>
      <li>基本数据类型的值</li>
      <li>引用类型的地址</li>
    </ul>
  </li>
  <li>堆：用于存放数据大小不固定的元素，包括数组和对象。</li>
</ul>

<h3 id="数组中元素的操作">数组中元素的操作</h3>

<h4 id="删除delete-数组名索引">删除：<code class="language-plaintext highlighter-rouge">delete 数组名[索引]</code></h4>

<pre><code class="language-JS">delete arr[1];
</code></pre>

<p>但是，删除后，数组长度并没有变化，被删除的数组元素为空，它的值是<code class="language-plaintext highlighter-rouge">undefined</code>替代。</p>

<h4 id="清空数组">清空数组</h4>

<ul>
  <li>直接将数组重新赋值为空数组 <code class="language-plaintext highlighter-rouge">arr = []</code></li>
  <li>或者也可以将数组的长度设置为0 <code class="language-plaintext highlighter-rouge">arr.length = 0</code></li>
</ul>

<h4 id="修改数组">修改数组</h4>

<p>就是对数组中的元素重新赋值。</p>

<pre><code class="language-JS">arr[1] = "number";
</code></pre>

<p>0 &lt;= 索引 &lt;= 数组的长度 - 1</p>

<h4 id="添加数组元素">添加数组元素</h4>

<p>索引 &gt;= 数组的长度</p>

<h3 id="数组的遍历">数组的遍历</h3>

<ul>
  <li>使用<code class="language-plaintext highlighter-rouge">for</code>循环遍历</li>
  <li>使用for…in…遍历 <code class="language-plaintext highlighter-rouge">for(变量 in 数组名)</code> 不过这里的变量是索引值，而不是数组中的元素</li>
</ul>

<h4 id="两种遍历方式的区别">两种遍历方式的区别</h4>

<ul>
  <li>使用<code class="language-plaintext highlighter-rouge">for</code>循环遍历数组（<strong>推荐使用</strong>）：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">for</code>循环中的i值数据类型为<code class="language-plaintext highlighter-rouge">number</code></li>
      <li>把数组中所有的值都遍历出来（包括不存在的值，比如说用<code class="language-plaintext highlighter-rouge">delete</code>删除的值）</li>
    </ul>
  </li>
  <li>使用<code class="language-plaintext highlighter-rouge">for in</code>循环遍历数组：
    <ul>
      <li>for…in中k值的数组类型为<code class="language-plaintext highlighter-rouge">String</code></li>
      <li>只遍历数组中存在的值（就是指具体数据的值），这种方式通常被称为枚举</li>
    </ul>
  </li>
</ul>

<h3 id="二维数组">二维数组</h3>

<p>以数组作为数组元素的数组</p>

<p>字面量方式很简单:</p>

<pre><code class="language-JS">var arr = [
  [1,2,3],
  ['number', 'string'],
  ['张三','李四']
];
</code></pre>

<p>下面是new字符定义数组：</p>

<pre><code class="language-JS">var arr = new Array(
  new Array(1, 2, 3),
  new  Array('number', 'string'),
  new Array('张三', '李四')
);
</code></pre>

<p>另外，还有第三种方式：先定义好多个一维数组，再将这些数组作为数组元素添加到一个一维数组中。</p>

<pre><code class="language-JS">var arr1 = [1,2,3];
var arr2 = ['number', 'string'];
var arr3 = ['张三','李四'];

varr arr4 = [arr1, arr2, arr3];
</code></pre>

<p>访问二位数组中元素的方法</p>

<p><code class="language-plaintext highlighter-rouge">arr[x][y]</code></p>

<h4 id="向二维数组中添加元素">向二维数组中添加元素</h4>

<p>和一维数组一个道理。</p>

<h3 id="数组自身的常用方法">数组自身的常用方法</h3>

<p>#### <code class="language-plaintext highlighter-rouge">Array.prototype.concat()</code></p>

<p>连接两个或更多的数组，并返回结果。</p>

<pre><code class="language-JS"> var arr
    
var arr1 = [1, 3, 5];

var arr2 = ["smith", "job", "white"];

var arr3 = ["a", "b", "c"];

var arr = arr1.concat(arr2, arr3);

    console.log(arr); // 输出为一个数组[1, 3, 5, "smith", "job", "white", "a", "b", "c"]
</code></pre>

<h4 id="arrayprototypejoin"><code class="language-plaintext highlighter-rouge">Array.prototype.join()</code></h4>

<p>把数组中所有元素按指定的分隔符分割，放入一个字符串</p>

<pre><code class="language-JS">var arr = ["smith", "white"];

var fullName = arr.join(' '); // 如果没有传值，默认用逗号分割

console.log(fullName); // 输出smith white
</code></pre>

<h4 id="arrayprototypepop"><code class="language-plaintext highlighter-rouge">Array.prototype.pop()</code></h4>

<p>删除并返回数组中的最后一个元素。</p>

<pre><code class="language-JS">var arr = ["a", "b", "c", "d"];

var popValue = arr.pop();

console.log(arr, popValue); // 原数组被删除元素。该方法返回的是被删除的元素

</code></pre>

<h4 id="arrayprototypeshift"><code class="language-plaintext highlighter-rouge">Array.prototype.shift()</code></h4>

<p>删除并返回数组中的第一个元素。</p>

<pre><code class="language-JS">var arr = ["a", "b", "c", "d"]; 

elem = arr.shift();

console.log(arr, elem); // 原数组变成["b", "c", "d"]。该方法返回的是被删除的元素
</code></pre>

<h4 id="arrayprototypepush">`Array.prototype.push()</h4>

<p>向数组的末尾添加一个或多个元素，并返回数组的长度。</p>

<pre><code class="language-JS">var arr = ["a", "b", "c", "d"];

var newArr = arr.push("e", "f");

console.log(arr, newArr); // 原数组变成["a", "b", "c", "d", "e", "f"]。该方法返回的是数组当前的长度
</code></pre>

<h4 id="arrayprototypeunshift"><code class="language-plaintext highlighter-rouge">Array.prototype.unshift()</code></h4>

<p>向数组的起始位置添加一个或多个元素，并返回数组的长度。</p>

<pre><code class="language-JS">var arr = ["a", "b", "c", "d"];

var newArr = arr.unshift(1, 2);

console.log(arr, newArr); // 原数组变成[1, 2, "a", "b", "c", "d"]。该方法返回的是数组当前的长度
</code></pre>

<h4 id="arrayprototypereverse"><code class="language-plaintext highlighter-rouge">Array.prototype.reverse()</code></h4>

<p>将原数组元素逆序排列</p>

<pre><code class="language-JS">var arr = ["e", "b", "c", "d"];

arr.reverse();

console.log(arr); // 原数组变成["d", "c", "b", "e"]
</code></pre>

<h4 id="arrayprototypeslicestart-end"><code class="language-plaintext highlighter-rouge">Array.prototype.slice(start, end)</code></h4>

<p>arr.slice(开始的位置, 结束的位置)，可从已有数组中返回选定的元素。</p>

<p>注意：slice方法是左闭右开，所以能取到开始位置的元素，而不能取到结束位置的元素。结束位置是可选的，如果没有，表示从开始位置到结束。</p>

<pre><code class="language-JS">var arr = ["a", "b", "c", "d"];

newArr = arr.slice(1, 2);

console.log(arr, newArr); // 原数组不变，该方法会返回新数组，显示"b"（遵循左闭右开的规则）

</code></pre>

<h4 id="arrayprototypesort"><code class="language-plaintext highlighter-rouge">Array.prototype.sort()</code></h4>

<p>规定排序顺序，原数组会被替换。</p>

<pre><code class="language-JS">var arr = [13, 9, 10, 34];

function compareNum (a, b) {
    return a-b; // a-b 按照从小到大的顺序排列，b-a按照从大到小的顺序排列
}

arr.sort(compareNum);

console.log(arr);// 显示[13, 9, 10, 34]
</code></pre>

<h4 id="arrayprototypesplice"><code class="language-plaintext highlighter-rouge">Array.prototype.splice()</code></h4>

<p><code class="language-plaintext highlighter-rouge">Array.prototype.splice(删除开始位置,删除多少个元素,在删除位置新增的元素A,在删除位置新增的元素B等等)</code></p>

<ul>
  <li>删除开始位置：必须有</li>
  <li>删除多少个元素：如果不想删除，只想添加，传入0 <code class="language-plaintext highlighter-rouge">arr.splice(2, 0, "newEleA", "newEleB")</code></li>
  <li>新增的元素：可选</li>
</ul>

<pre><code class="language-JS">var arr = ["红楼梦", "西游记", "水浒传", "三国演义"];

arr.splice(1, 2, "曹雪芹", "罗贯中");

console.log(arr); // 原数组被替换，变成了["红楼梦", "曹雪芹", "罗贯中", "三国演义"]
</code></pre>

<h4 id="选择排序arrayprototype">选择排序：<code class="language-plaintext highlighter-rouge">Array.prototype.()</code></h4>

<h4 id="冒泡排序arrayprototype">冒泡排序：<code class="language-plaintext highlighter-rouge">Array.prototype.()</code></h4>

<h2 id="对象">对象</h2>

<h3 id="内置对象">内置对象</h3>

<ul>
  <li>String：字符串对象</li>
  <li>Math：数学对象</li>
  <li>Number：数字对象</li>
  <li>Date：日期对象</li>
  <li>BOM：浏览器对象模型，操作浏览器（了解即可）</li>
  <li>DOM：文档对象模型，操作文档</li>
</ul>

<h3 id="自定义对象">自定义对象</h3>

<p>自己定义的对象。</p>

<p>定义对象的两种方式</p>

<ul>
  <li>第一种方式：使用<code class="language-plaintext highlighter-rouge">new</code>字符来实例化对象 <code class="language-plaintext highlighter-rouge">new Object()</code></li>
  <li>第二种方式：使用字面量的方式定义对象 <code class="language-plaintext highlighter-rouge">var obj = {}</code></li>
</ul>

<h4 id="给对象添加属性和方法">给对象添加属性和方法</h4>

<ul>
  <li>第一种方式：通过对象来添加 <code class="language-plaintext highlighter-rouge">object.attribute = value</code></li>
  <li>第二种方式：</li>
</ul>

<h4 id="方法中的this">方法中的<code class="language-plaintext highlighter-rouge">this</code></h4>

<p><code class="language-plaintext highlighter-rouge">this</code>表示调用该方法的对象</p>

<h3 id="字符串对象的方法">字符串对象的方法</h3>

<h4 id="stringlength"><code class="language-plaintext highlighter-rouge">string.length</code></h4>

<p>字符串对象的长度</p>

<h4 id="stringcharat索引值"><code class="language-plaintext highlighter-rouge">string.charAt(索引值)</code></h4>

<p>返回在指定索引值位置的字符。</p>

<p>索引超出，返回空字符串</p>

<pre><code class="language-JS">var str1 = "note";

var letter = str1.charAt(5);

console.log(letter); // 索引超出 为空字符串

var charType = typeof(letter); // 类型为String


console.log(charType)
</code></pre>

<h4 id="stringindexof"><code class="language-plaintext highlighter-rouge">string.indexOf()</code></h4>

<p>返回某个指定的字符串值在字符串中<strong>首次</strong>出现的位置。</p>

<p><code class="language-plaintext highlighter-rouge">string.indexOf(searchvalue, fromindex)</code></p>

<p>searchvalue可以是多个字符。</p>

<pre><code class="language-JS">var name = "this is a box";

var aLetter = name.indexOf("s");

console.log(`第一个s是第${aLetter + 1}个字母`) // 是索引值哦，所以真正的位置要+1

var zLetter = name.indexOf("z");

console.log(zLetter); // 返回-1，不存在的字符串总是返回-1
</code></pre>

<h4 id="stringlastindexof"><code class="language-plaintext highlighter-rouge">string.lastIndexOf()</code></h4>

<p>查找字符串值最后一次出现的位置</p>

<pre><code class="language-JS">var str = "this is a box. that's is a Box";

var is = str.lastIndexOf("is");

console.log(is) // 22
</code></pre>

<h4 id="stringreplaceregexpsubstr-replacement"><code class="language-plaintext highlighter-rouge">string.replace(regexp/substr, replacement)</code></h4>

<p>用新字符去替换既有字符。</p>

<p><code class="language-plaintext highlighter-rouge">string.replace(既有字符，新字符)</code></p>

<pre><code class="language-JS">var str = "this is a box. that's is a Box";

newStr = str.replace("is", "**"); // string.replace方法并不会改变原字符串，而是返回一个新的字符串
console.log(newStr); // 默认只替换了第一个匹配值

// 如果要替换所有匹配值，需要使用正则

strAll = str.replace(/is/g, "**" ) // g: global

console.log(strAll);
</code></pre>

<h4 id="stringsubstr"><code class="language-plaintext highlighter-rouge">string.substr()</code></h4>

<p><code class="language-plaintext highlighter-rouge">substr</code>没有使用驼峰命名法。</p>

<p><code class="language-plaintext highlighter-rouge">string.substr(从指定的索引值开始截取字符串, 截取多少个字符)</code></p>

<pre><code class="language-JS">var str = "this is a box. that's is a Box";

var subStr = str.substr(2, 5); // 如果起始位置超过了字符串长度，返回空字符串。

console.log(subStr);
</code></pre>

<h4 id="stringsubstring"><code class="language-plaintext highlighter-rouge">string.substring()</code></h4>

<p><code class="language-plaintext highlighter-rouge">string.substring(从什么位置开始截取，截取到什么位置)</code></p>

<p>注意，和<code class="language-plaintext highlighter-rouge">string.substr()</code>不一样。</p>

<p>另外，还有一点很重要，截取的范围是一个左闭右开的区间。</p>

<pre><code class="language-JS">var str = "this is a box. that's is a Box";

var subString = str.substring(2, 5); // 如果未定义结束位置，将截取到最后

console.log(subString); // 这次，返回的是is (is后面还有个空格)
</code></pre>

<h4 id="stringtolowercase"><code class="language-plaintext highlighter-rouge">string.toLowerCase</code></h4>

<h4 id="stringtouppercase"><code class="language-plaintext highlighter-rouge">string.toUpperCase</code></h4>

<h3 id="number-对象">Number 对象</h3>

<p><code class="language-plaintext highlighter-rouge">toFixed()</code></p>

<p>四舍五入为指定小数位数的数字。</p>

<h3 id="math-对象">Math 对象</h3>

<h4 id="mathpi"><code class="language-plaintext highlighter-rouge">Math.PI</code></h4>

<pre><code class="language-JS">console.log(Math.PI); // 返回π值`
</code></pre>

<h4 id="mathabsx"><code class="language-plaintext highlighter-rouge">Math.abs(x)</code></h4>

<p>返回数x的绝对值</p>

<pre><code class="language-JS">Math.abs(-1) // 返回1
</code></pre>

<h4 id="mathceilx"><code class="language-plaintext highlighter-rouge">Math.ceil(x)</code></h4>

<p>对一个数x向上取整数。</p>

<pre><code class="language-JS">Math.ceil(3.4) // 返回4
</code></pre>

<h4 id="mathfloorx"><code class="language-plaintext highlighter-rouge">Math.floor(x)</code></h4>

<p>对一个数x向上取整数。</p>

<pre><code class="language-JS">Math.floor(3.4) // 返回3
</code></pre>

<h4 id="mathmaxx"><code class="language-plaintext highlighter-rouge">Math.max(x)</code></h4>

<p>求最大值。</p>

<pre><code class="language-JS">Math.max(Math.PI, 1, -3)
</code></pre>

<h4 id="mathminx"><code class="language-plaintext highlighter-rouge">Math.min(x)</code></h4>

<p>求最小值。</p>

<p><code class="language-plaintext highlighter-rouge">Math.pow(x,y)</code></p>

<p>返回x的y次幂值</p>

<p>Math.pow(2, 3) // 8</p>

<p><code class="language-plaintext highlighter-rouge">Math.random()</code></p>

<p>返回介于0到2之间的一个随机数，包含0不包含1。</p>

<p><code class="language-plaintext highlighter-rouge">Math.round(x)</code></p>

<p>可以把一个数字舍入为最接近的整数。</p>

<pre><code class="language-JS">Math.round(3.6);
</code></pre>

<h4 id="获取指定范围的随机整数">获取指定范围的随机整数</h4>

<h3 id="date-对象">Date 对象</h3>

<h4 id="new-date"><code class="language-plaintext highlighter-rouge">new Date()</code></h4>

<p>获取当前计算机时间。</p>

<h4 id="new-datedateval"><code class="language-plaintext highlighter-rouge">new Date(dateVal)</code></h4>

<p>获取给定时间。</p>

<h4 id="时间差">时间差</h4>

<h4 id="获取年月日等具体信息">获取年月日等具体信息</h4>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在页面中显示时间: 2017-3-30 18:03:46星期四</span>

<span class="kd">var</span> <span class="nx">localTime</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">localTime</span><span class="p">);</span>

<span class="c1">// 获取年</span>

<span class="nx">year</span> <span class="o">=</span> <span class="nx">localTime</span><span class="p">.</span><span class="nx">getFullYear</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">year</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">month</span> <span class="o">=</span> <span class="nx">localTime</span><span class="p">.</span><span class="nx">getMonth</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">day</span> <span class="o">=</span> <span class="nx">localTime</span><span class="p">.</span><span class="nx">getDate</span><span class="p">();</span> <span class="c1">// 不是getDay()，getDay是返回一周中的某一天</span>

<span class="kd">var</span> <span class="nx">weekday</span> <span class="o">=</span> <span class="nx">localTime</span><span class="p">.</span><span class="nx">getDay</span><span class="p">();</span><span class="c1">// 完全可以理解成为索引值</span>

<span class="kd">var</span> <span class="nx">hour</span> <span class="o">=</span> <span class="nx">localTime</span><span class="p">.</span><span class="nx">getHours</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">localTime</span><span class="p">.</span><span class="nx">getMinutes</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">sec</span> <span class="o">=</span> <span class="nx">localTime</span><span class="p">.</span><span class="nx">getSeconds</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">week</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">星期日</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">星期一</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">星期二</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">星期三</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">星期四</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">星期五</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">星期六</span><span class="dl">'</span><span class="p">];</span> <span class="c1">//将weekday作为索引值去遍历这个数组，就能获取中文的weekday信息</span>

<span class="nx">weedayCn</span> <span class="o">=</span> <span class="nx">week</span><span class="p">[</span><span class="nx">weekday</span><span class="p">];</span>

<span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nx">year</span><span class="p">}</span><span class="s2">-</span><span class="p">${</span><span class="nx">month</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span><span class="s2">-</span><span class="p">${</span><span class="nx">day</span><span class="p">}</span><span class="s2"> </span><span class="p">${</span><span class="nx">hour</span><span class="p">}</span><span class="s2">:</span><span class="p">${</span><span class="nx">min</span><span class="p">}</span><span class="s2">:</span><span class="p">${</span><span class="nx">sec</span><span class="p">}${</span><span class="nx">weedayCn</span><span class="p">}</span><span class="s2">`</span> <span class="c1">// 月份需要+1</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span><span class="o">*</span><span class="sr">/</span><span class="err">

</span></code></pre></div></div>

<h4 id="将时间转换为字符串">将时间转换为字符串</h4>

<pre><code class="language-JS">var mydate = new Date();

// 转换为字符串

mydate = mydate.toLocaleString();

console.log(mydate);

</code></pre>

<h2 id="js的组成">JS的组成</h2>

<ul>
  <li>ECMAScript: js基本语法、函数、数组和对象<br />
ES5 (2018年1月还是主流) ES6 (2015年发布) ES7(还存在兼容性问题)</li>
  <li>DOM (Document Object Model)，主要操作的是HTML标签，使JavaScript有能力与HTML文档的所有元素“对话”</li>
  <li>BOM (Browser Object Model)，主要操作的是浏览器窗口，使JavaScript有能力与浏览器“对话”
    <ul>
      <li>操作浏览器窗口</li>
      <li>访问浏览器历史</li>
    </ul>
  </li>
</ul>

<p>BOM 和 DOM 是独立于程序语言和平台的标准，W3C定义了一组标准接口，而这些接口在浏览器中以对象的形式实现。BOM与DOM均由一组对象组成，对象定义了<strong>属性</strong>和<strong>方法</strong>。</p>

<p><strong>注意</strong>：</p>

<ul>
  <li>BOM 和 DOM 只是一个概念 (一个模型)，而不是具体的对象，它们是由多个对象组成的集合。</li>
  <li><code class="language-plaintext highlighter-rouge">window</code>对象中有个属性是<code class="language-plaintext highlighter-rouge">document</code>，<code class="language-plaintext highlighter-rouge">document</code>又是一个对象 — 就是 DOM 对象模型。</li>
</ul>

<h3 id="bom">BOM</h3>

<p>BOM 对象的结构：</p>

<ol>
  <li>BOM对象中最顶层的对象是<code class="language-plaintext highlighter-rouge">window</code>对象</li>
  <li>window对象中有很多属性，这些属性少数又是一个对象
    <ul>
      <li>window.document：DOM对象模型</li>
      <li>window.history：历史对象</li>
      <li>window.location：地址对象</li>
      <li>window.navigator：导航对象</li>
      <li>windows.screen：屏幕对象</li>
      <li>frames[]：框架对象</li>
    </ul>
  </li>
</ol>

<h3 id="window-对象">window 对象</h3>

<p>window对象是脚本中的全局对象，可以在任何地方调用。</p>

<ol>
  <li>window对象：全局对象（可以省略不写）<br />
window.alert() 简写成 alert();</li>
  <li>window全局对象中的属性：全局属性（全局变量）
<strong>注意</strong>：在外部定义的变量和函数，其实就是全局对象中的属性和方法。</li>
</ol>

<h3 id="window对象中的方法">window对象中的方法</h3>

<h4 id="alert"><code class="language-plaintext highlighter-rouge">alert()</code></h4>

<p>略</p>

<h4 id="confirm"><code class="language-plaintext highlighter-rouge">confirm()</code></h4>

<p>显示带有一段消息以及确认按钮以及取消按钮的对话框。点击不同的按钮返回不同的值</p>

<ul>
  <li>确定按钮：<code class="language-plaintext highlighter-rouge">true</code></li>
  <li>取消按钮：<code class="language-plaintext highlighter-rouge">false</code></li>
</ul>

<p>可以用if语句一起使用，实现控制。</p>

<pre><code class="language-JS">var a = confirm("确定要删除文件吗？");

if(a) {
    ...
} else {
    ...
}
</code></pre>

<h4 id="计时器">计时器</h4>

<ul>
  <li>间歇调用：每隔多少毫秒调用代码块：
    <ul>
      <li>第一种写法：<code class="language-plaintext highlighter-rouge">setInterval(function, interval)</code>，比如<code class="language-plaintext highlighter-rouge">setInterval((){}, 500)</code>，例子中的函数是匿名函数。</li>
      <li>第二种写法：可以把匿名函数调出来，然后传入函数名，比如说<code class="language-plaintext highlighter-rouge">funciton 函数名() {}</code>，然后<code class="language-plaintext highlighter-rouge">setInterval(函数名, 500)</code> 。注意，函数名的话，后面不跟括号哦。</li>
    </ul>
  </li>
  <li>超时调用：经过若干秒只调用一次代码块。<br />
语法：<code class="language-plaintext highlighter-rouge">setTimeout(function, interval)</code>，同样有两种写法，和间歇调用类似</li>
</ul>

<p><strong>注意</strong>：推荐使用间歇调用。</p>

<h5 id="清除计时器">清除计时器</h5>

<p><code class="language-plaintext highlighter-rouge">clearInterval(间歇调用ID号)</code></p>

<p>每创建一个计时器，就会自动赋予一个ID号。</p>

<p><code class="language-plaintext highlighter-rouge">cleearTimeout(超时调用ID号)</code></p>

<h3 id="bom-中的其他对象">BOM 中的其他对象</h3>

<h4 id="screen-对象">screen 对象</h4>

<p><code class="language-plaintext highlighter-rouge">window.screen</code></p>

<h4 id="history-对象">history 对象</h4>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">length</code>属性：表示当前打开的浏览器历史列中的URL数。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">back()</code>：访问上一个页面：<code class="language-plaintext highlighter-rouge">history.back()</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">forward()</code>：访问下一个页面 <code class="language-plaintext highlighter-rouge">history.forward()</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">go(1)</code>：参数可正可负，跳到指定页面 <code class="language-plaintext highlighter-rouge">history.go(-2)</code>，就是跳到上上个页面。</p>
  </li>
</ul>

<h4 id="location-对象">location 对象</h4>

<p>操作地址栏。</p>

<p>地址的组成部分：</p>

<ul>
  <li>protocol：协议</li>
  <li>hash: 表示URL地址中的锚点部分，包括前导符#。</li>
  <li>host：表示主机名（hostname）和端口号（port），即IP地址或者域名端口。</li>
  <li>pathname：页面路径，包含页面文件名称</li>
  <li>search：参数部分</li>
  <li>href：所有地址 (<code class="language-plaintext highlighter-rouge">location.href</code>，获取当前页面的地址)，可读可写。<code class="language-plaintext highlighter-rouge">location.href="https://www.youtube.com"</code></li>
</ul>

<h4 id="练习若干秒后跳转页面">练习：若干秒后跳转页面</h4>

<pre><code class="language-HTML">&lt;head&gt;
  ...
  &lt;style&gt;
    * {
        background-color: #000;
        color: #fff;
        line-height: 40px;
        text-align: center;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;&lt;span id="sec"&gt;&lt;/span&gt; 秒后将跳转到 www.baidu.com&lt;/p&gt;
&lt;/body&gt;
</code></pre>

<pre><code class="language-JS">var n = 5;
document.getElementById('sec').innerHTML = n;

setInterval(function() {
    n--;
    if (n===0) {
        location.href="https://www.baidu.com";
    } else {
        document.getElementById('sec').innerHTML = n;
    }
}, 1000)
</code></pre>

<h4 id="navigator-对象">navigator 对象</h4>

<p>包含了浏览器的所有信息。</p>

<p><code class="language-plaintext highlighter-rouge">navigator.userAgent</code>返回客户机发送给服务器的user-agent头部的值，可以使用它来判断打开当前文件的是什么浏览器（是chrome，firefox还是ie）</p>

<h2 id="dom-文档对象">DOM 文档对象</h2>

<ul>
  <li>
    <p>核心DOM：用于XML与HTML的共用接口（方法），可以用来操作节点数，</p>
  </li>
  <li>
    <p>XML DOM（不用掌握）：用于专门操作XML</p>
  </li>
  <li>
    <p>HTML DOM：针对标签中的属性进行操作（修改属性、获取属性的值）。</p>
  </li>
</ul>

<h3 id="html-节点数">HTML 节点数</h3>

<p>通过节点数得到的结论：</p>

<ol>
  <li>整个文档就是一个节点：文档节点 - document</li>
  <li>而每个HTML标签就是一个元素节点</li>
  <li>标签中的文字则是文字节点</li>
  <li>标签中的属性则是属性节点</li>
  <li>一切都是节点。</li>
</ol>

<h3 id="获取元素的方法">获取元素的方法</h3>

<p>DOM：操作网页的内容，包括：</p>

<ul>
  <li>标签</li>
  <li>标签中的属性</li>
  <li>css样式属性</li>
  <li>标签中的内容</li>
</ul>

<p>有几种方法：</p>

<ul>
  <li>通过id获取元素（标签）<br />
语法结构：<br />
  <code class="language-plaintext highlighter-rouge">document.getElementById("ID名")</code>
<strong>注意</strong>：id在页面中是唯一的。所以通过id获取的元素只有一个。</li>
  <li>
    <p>通过标签名获取
语法结构：
  <code class="language-plaintext highlighter-rouge">document.getElementsByTagName("标签名称")</code>
<strong>注意</strong>：通过标签名获取的结果是一个数组 | 获取某个范围A内的元素B： 1. 先获取该范围A； 2. 再到A下面获取元素B | 获取到的数组不能直接使用，必须要精确到其中的元素才能使用</p>
  </li>
  <li>
    <p>通过类名获取元素
语法结构：
  <code class="language-plaintext highlighter-rouge">document.getElementsByClassName("类名")</code>
<strong>注意</strong>：这种获取方式在IE9下不兼容</p>
  </li>
  <li>通过Name属性值获取：一般针对表单中的空间（input select textarea button）
语法结构：
  <code class="language-plaintext highlighter-rouge">document.getElementByName("name值")</code> » 只能使用document
<strong>注意</strong>：这个结构只能在<code class="language-plaintext highlighter-rouge">document</code>下面获取</li>
</ul>

<h4 id="快速访问方式-了解">快速访问方式 (了解)</h4>

<p>通过<code class="language-plaintext highlighter-rouge">name</code>属性快速访问元素，主要针对表单。存在兼容性问题，一般不使用，了解即可。</p>

<pre><code class="language-JS">myformObj = document.myform;
console.log(myformObj);
</code></pre>

<pre><code class="language-JS">myformObj = document.myform;
// 通过name属性快速访问input框
sex1 = myformObj.sex1;
console.log(myformObj);
console.log(sex1)
</code></pre>

<h4 id="html5快速访问">HTML5快速访问</h4>

<p>兼容高版本的浏览器。</p>

<p><code class="language-plaintext highlighter-rouge">document.querySelector("选择器")</code> // 返回页面中的第一个元素</p>

<p><code class="language-plaintext highlighter-rouge">document.querySelectorAll("选择器")</code> // 返回页面中所有匹配的元素</p>

<p>选择器：</p>

<ul>
  <li>id名：#id</li>
  <li>类名：.类名</li>
  <li>标签名：标签名</li>
</ul>

<p>console.debug(): 专门用来打印对象</p>

<p>元素对象中的属性：HTML标记的属性（标签属性）对应于元素对象的一个同名属性。</p>

<p>通过元素对象中的同名属性进行访问和修改。</p>

<h3 id="获取属性">获取属性</h3>

<p>对象.属性名</p>

<h3 id="表单对象中的属性">表单对象中的属性</h3>

<p>属性：</p>

<ul>
  <li>length: 表示表单中控件(input textarea button select)的个数 （不包含label）</li>
  <li>elements: 访问表单中的所有控件的一个数组</li>
</ul>

<h3 id="表单对象中的方法">表单对象中的方法</h3>

<p><code class="language-plaintext highlighter-rouge">onsubmit</code>：在提交表单之前调用，如果onsubmit，返回true，则提交表单，返回false，则阻止表单提交。</p>

<p>注意：</p>

<ul>
  <li>在提交表单之前触发，验证用户信息是否正确。正确就提交，错误则不提交。</li>
  <li>如果函数没有返回值，默认返回true</li>
</ul>

<p>书写位置：在表单标签中作为标签属性添加。</p>

<h3 id="阻止浏览器的默认行为">阻止浏览器的默认行为</h3>

<h3 id="onreset"><code class="language-plaintext highlighter-rouge">onreset</code></h3>

<p>在表单被重置前调用。如果onreset返回true，则重置表单，返回false则组织表单重置。</p>

<p>同样绑定在表单上。</p>

<h3 id="submit">submit()</h3>

<p>form对象上的提交方法。</p>

<p>注意：普通按钮是不能直接提交的，可以通过添加点击事件来触发表单提交。</p>

<h4 id="文本对象">文本对象</h4>

<p>获取input框。</p>

<p>像disabled这种二选一的状态值，用js来设置属性值得时候统一用Boolean值。</p>

<p>checked：单选和复选框的选中</p>

<p>selected：下拉框的选中</p>

<p>readOnly</p>

<p>设置标签属性时：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">disabled = "disabled"</code></li>
  <li><code class="language-plaintext highlighter-rouge">disabled</code></li>
</ul>

<h2 id="第七天节点操作">第七天：节点操作</h2>

<h3 id="获取根节点">获取根节点</h3>

<p>###</p>

:ET